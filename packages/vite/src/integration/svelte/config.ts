import crypto from "node:crypto";
import os from "node:os";
import path from "node:path";

import type { ManifestTransform } from "@serwist/build";
import { errors } from "@serwist/build";
import type { ResolvedConfig } from "vite";

import type { PluginOptions as BasePluginOptions } from "../../types.js";
import { resolveEntry } from "../../utils.js";
import type { KitOptions } from "./types.js";

export const configurateSvelteKitOptions = (viteConfig: ResolvedConfig, kit: KitOptions, options: BasePluginOptions) => {
  const clientOutDir = path.resolve(viteConfig.root, viteConfig.build.outDir, "../client");

  // Kit fixes the service worker's name to 'service-worker.js'
  if (viteConfig.isProduction) {
    options.swSrc = path.resolve(clientOutDir, "service-worker.js");
    options.swDest = path.resolve(clientOutDir, "service-worker.js");
  } else {
    const swSrc = resolveEntry(path.join(viteConfig.root, kit.files?.serviceWorker ?? "src/service-worker"));
    if (swSrc) {
      options.swSrc = swSrc;
      options.swDest = path.join(os.tmpdir(), `serwist-vite-integration-svelte-${crypto.randomUUID()}.js`);
    } else {
      throw new Error(errors["invalid-sw-src"]);
    }
  }
  options.swUrl = "/service-worker.js";

  // SvelteKit's outDir is `.svelte-kit/output/client`.
  // We need to include the parent folder in globDirectory since SvelteKit will generate SSG in `.svelte-kit/output/prerendered` folder.
  if (!options.globDirectory) {
    options.globDirectory = path.resolve(clientOutDir, "..");
  }
  if (!options.manifestTransforms) {
    options.manifestTransforms = [createManifestTransform(viteConfig.base, undefined, kit)];
  }

  let buildAssetsDir = kit.appDir ?? "_app/";
  if (buildAssetsDir[0] === "/") buildAssetsDir = buildAssetsDir.slice(1);
  if (buildAssetsDir[buildAssetsDir.length - 1] !== "/") buildAssetsDir += "/";

  if (!options.modifyURLPrefix) {
    options.globPatterns = buildGlobPatterns(options.globPatterns);
    if (kit.includeVersionFile) {
      options.globPatterns.push(`client/${buildAssetsDir}version.json`);
    }
  }

  // Exclude server assets: sw is built on SSR build
  options.globIgnores = buildGlobIgnores(options.globIgnores);

  // Vite 5 support: allow override dontCacheBustURLsMatching
  if (!("dontCacheBustURLsMatching" in options)) {
    options.dontCacheBustURLsMatching = new RegExp(`${buildAssetsDir}immutable/`);
  }

  if (!options.injectionPoint) {
    options.injectionPoint = "self.__SW_MANIFEST";
  }
};

export function createManifestTransform(base: string, webManifestName?: string, options?: KitOptions): ManifestTransform {
  return async (entries) => {
    const defaultAdapterFallback = "prerendered/fallback.html";
    const suffix = options?.trailingSlash === "always" ? "/" : "";
    let adapterFallback = options?.adapterFallback;
    let excludeFallback = false;
    // the fallback will be always generated by SvelteKit.
    // The adapter will copy the fallback only if it is provided in its options: we need to exclude it
    if (!adapterFallback) {
      adapterFallback = defaultAdapterFallback;
      excludeFallback = true;
    }

    // the fallback will be always in .svelte-kit/output/prerendered/fallback.html
    const manifest = entries
      .filter(({ url }) => !(excludeFallback && url === defaultAdapterFallback))
      .map((e) => {
        let url = e.url;
        // client assets in `.svelte-kit/output/client` folder.
        // SSG pages in `.svelte-kit/output/prerendered/pages` folder.
        // fallback page in `.svelte-kit/output/prerendered` folder (fallback.html is the default).
        if (url.startsWith("client/")) url = url.slice(7);
        else if (url.startsWith("prerendered/pages/")) url = url.slice(18);
        else if (url === defaultAdapterFallback) url = adapterFallback!;

        if (url.endsWith(".html")) {
          if (url.startsWith("/")) url = url.slice(1);

          if (url === "index.html") {
            url = base;
          } else {
            const idx = url.lastIndexOf("/");
            if (idx > -1) {
              // abc/index.html -> abc/?
              if (url.endsWith("/index.html")) url = `${url.slice(0, idx)}${suffix}`;
              // abc/def.html -> abc/def/?
              else url = `${url.substring(0, url.lastIndexOf("."))}${suffix}`;
            } else {
              // xxx.html -> xxx/?
              url = `${url.substring(0, url.lastIndexOf("."))}${suffix}`;
            }
          }
        }

        e.url = url;

        return e;
      });

    if (!webManifestName) return { manifest };

    return { manifest: manifest.filter((e) => e.url !== webManifestName) };
  };
}

export function buildGlobPatterns(globPatterns?: string[]) {
  if (globPatterns) {
    if (!globPatterns.some((g) => g.startsWith("prerendered/"))) globPatterns.push("prerendered/**/*.html");

    if (!globPatterns.some((g) => g.startsWith("client/"))) globPatterns.push("client/**/*.{js,css,ico,png,svg,webp,webmanifest}");

    if (!globPatterns.some((g) => g.includes("webmanifest"))) globPatterns.push("client/*.webmanifest");

    return globPatterns;
  }

  return ["client/**/*.{js,css,ico,png,svg,webp,webmanifest}", "prerendered/**/*.html"];
}

export function buildGlobIgnores(globIgnores?: string[]) {
  if (globIgnores) {
    if (!globIgnores.some((g) => g.startsWith("server/"))) globIgnores.push("server/*.*");

    return globIgnores;
  }

  return ["server/*.*"];
}
